From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ishland <ishlandmc@yeah.net>
Date: Tue, 9 Feb 2021 16:55:59 +0800
Subject: [PATCH] fixup! Multithreaded entity tracking


diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index e265a10781286a94d81086731ec0d3330dc3977f..359fccf1a41d6e2ab4576113e796b8baa22a4f8c 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -2123,6 +2123,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private final java.util.concurrent.ConcurrentLinkedQueue<Runnable> trackerMainQueue = new java.util.concurrent.ConcurrentLinkedQueue<>();
     private gg.airplane.structs.TrackQueue trackQueue;
 
+    PlayerChunk trackerGetVisibleChunk(long key) {
+        return ((ProtectedVisibleChunksMap)this.visibleChunks).safeGet(key);
+    }
+
     void trackerEnsureMain(Runnable runnable) {
         if (this.world.serverThread == Thread.currentThread()) {
             runnable.run();
@@ -2138,7 +2142,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         try {
             // Airplane start - multithreaded tracker
             if (this.trackQueue == null) this.trackQueue = new gg.airplane.structs.TrackQueue(this.world.getChunkProvider().entityTickingChunks, trackerMainQueue);
-            if (gg.airplane.AirplaneConfig.multithreadedEntityTracker && this.world.getChunkProvider().entityTickingChunks.size() < 1000) {
+            if (gg.airplane.AirplaneConfig.multithreadedEntityTracker && (this.world.getChunkProvider().entityTickingChunks.size() * (this.world.getMinecraftServer().getPlayerCount() * 2 + 1)) > 1000) {
                 this.trackQueue.start();
                 return;
             }
@@ -2465,11 +2469,9 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
         }
 
         public void broadcast(Packet<?> packet) {
-            Iterator iterator = this.trackedPlayers.iterator();
-
-            while (iterator.hasNext()) {
-                EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+            final EntityPlayer[] trackedPlayers = this.trackedPlayers.toArray(new EntityPlayer[0]); // Airplane - avoid CME
 
+            for (EntityPlayer entityplayer : trackedPlayers) { // Airplane - avoid CME
                 entityplayer.playerConnection.sendPacket(packet);
             }
 
@@ -2519,7 +2521,7 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
 
                     if (!flag1) {
                         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(this.tracker.chunkX, this.tracker.chunkZ);
-                        PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
+                        PlayerChunk playerchunk = PlayerChunkMap.this.trackerGetVisibleChunk(chunkcoordintpair.pair());
 
                         if (playerchunk != null && playerchunk.getSendingChunk() != null) { // Paper - no-tick view distance
                             flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.viewDistance;
