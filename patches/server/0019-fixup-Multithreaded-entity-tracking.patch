From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ishland <ishlandmc@yeah.net>
Date: Tue, 9 Feb 2021 16:55:59 +0800
Subject: [PATCH] fixup! Multithreaded entity tracking


diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index e265a10781286a94d81086731ec0d3330dc3977f..7bd33090605e55a92cadccac5aeb0b511767b9e5 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -2122,6 +2122,20 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // Airplane start - tools to ensure main thread
     private final java.util.concurrent.ConcurrentLinkedQueue<Runnable> trackerMainQueue = new java.util.concurrent.ConcurrentLinkedQueue<>();
     private gg.airplane.structs.TrackQueue trackQueue;
+    private final com.google.common.cache.LoadingCache<Long, PlayerChunk> trackerVisibleChunkCache = com.google.common.cache.CacheBuilder.newBuilder().build(
+            new com.google.common.cache.CacheLoader<Long, PlayerChunk>() {
+                @Override
+                public PlayerChunk load(@javax.annotation.Nonnull Long key) {
+                    return getVisibleChunk(key);
+                }
+            });
+
+    PlayerChunk trackerGetVisibleChunk(long key) {
+        if (this.world.serverThread == Thread.currentThread())
+            return getVisibleChunk(key);
+        else
+            return trackerVisibleChunkCache.getUnchecked(key);
+    }
 
     void trackerEnsureMain(Runnable runnable) {
         if (this.world.serverThread == Thread.currentThread()) {
@@ -2140,6 +2154,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             if (this.trackQueue == null) this.trackQueue = new gg.airplane.structs.TrackQueue(this.world.getChunkProvider().entityTickingChunks, trackerMainQueue);
             if (gg.airplane.AirplaneConfig.multithreadedEntityTracker && this.world.getChunkProvider().entityTickingChunks.size() < 1000) {
                 this.trackQueue.start();
+                this.trackerVisibleChunkCache.invalidateAll();
                 return;
             }
             // Airplane end
@@ -2465,11 +2480,9 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
         }
 
         public void broadcast(Packet<?> packet) {
-            Iterator iterator = this.trackedPlayers.iterator();
-
-            while (iterator.hasNext()) {
-                EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+            final EntityPlayer[] trackedPlayers = this.trackedPlayers.toArray(new EntityPlayer[0]); // Airplane - avoid CME
 
+            for (EntityPlayer entityplayer : trackedPlayers) { // Airplane - avoid CME
                 entityplayer.playerConnection.sendPacket(packet);
             }
 
@@ -2519,7 +2532,7 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
 
                     if (!flag1) {
                         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(this.tracker.chunkX, this.tracker.chunkZ);
-                        PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
+                        PlayerChunk playerchunk = PlayerChunkMap.this.trackerGetVisibleChunk(chunkcoordintpair.pair());
 
                         if (playerchunk != null && playerchunk.getSendingChunk() != null) { // Paper - no-tick view distance
                             flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.viewDistance;
