From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ishland <ishlandmc@yeah.net>
Date: Tue, 9 Feb 2021 16:55:59 +0800
Subject: [PATCH] fixup! Multithreaded entity tracking


diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 3b27ebb0c9fa9d2b6e18d60288f679c5be2f2144..30042a21fa38e5188e9072fff3cd8ba75b3583ca 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -76,7 +76,7 @@ public class Chunk implements IChunkAccess {
                     PlayerChunkMap.EntityTracker tracker = ((WorldServer) Chunk.this.getWorld()).getChunkProvider().playerChunkMap.trackedEntities.get(entity.getId());
                     if (tracker != null) {
                         tracker.updatePlayers(tracker.tracker.getPlayersInTrackRange());
-                        tracker.tickEntry();
+                        tracker.trackerEntry.tick();
                     }
                 }
             }
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index 864d5a0bd55fd763e51759bc5a5ce951d403504b..9c48ca1e35f396be757e748c5aacecb0f2aae91f 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -73,7 +73,7 @@ public class EntityTrackerEntry {
     }
 
     public final void tick() { this.a(); } // Paper - OBFHELPER
-    public void a() {
+    public synchronized void a() { // Airplane - sync
         //com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Tracker update"); // Tuinity // Airplane - allow multithreaded
         List<Entity> list = this.tracker.getPassengers();
 
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 3d2c2cfd60ead1a5412daa8ca5956828b4361e1c..311531fdbe352294788e213e6b4fa96345ec80ee 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -20,6 +20,7 @@ import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap; // Airplane
 import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import java.io.File;
@@ -64,6 +65,14 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     public final Long2ObjectLinkedOpenHashMap<PlayerChunk> visibleChunks = new ProtectedVisibleChunksMap(); // Paper - faster copying
 
     private class ProtectedVisibleChunksMap extends com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<PlayerChunk> {
+        // Airplane start - readonly protection
+        private volatile boolean readOnly = false;
+        @Override
+        public void copyFrom(com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<PlayerChunk> map) {
+            if (readOnly) throw new IllegalStateException("Readonly mode");
+            super.copyFrom(map);
+        }
+        // Airplane end
         @Override
         public PlayerChunk put(long k, PlayerChunk playerChunk) {
             throw new UnsupportedOperationException("Updating visible Chunks");
@@ -2123,6 +2132,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private final java.util.concurrent.ConcurrentLinkedQueue<Runnable> trackerMainQueue = new java.util.concurrent.ConcurrentLinkedQueue<>();
     private gg.airplane.structs.TrackQueue trackQueue;
 
+    PlayerChunk trackerGetVisibleChunk(long key) {
+        return ((ProtectedVisibleChunksMap)this.visibleChunks).safeGet(key);
+    }
+
     void trackerEnsureMain(Runnable runnable) {
         if (this.world.serverThread == Thread.currentThread()) {
             runnable.run();
@@ -2135,10 +2148,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // Paper start - optimised tracker
     private final void processTrackQueue() {
         this.world.timings.tracker1.startTiming();
+        ((ProtectedVisibleChunksMap) this.visibleChunks).readOnly = true; // Airplane - readonly protection
         try {
             // Airplane start - multithreaded tracker
             if (this.trackQueue == null) this.trackQueue = new gg.airplane.structs.TrackQueue(this.world.getChunkProvider().entityTickingChunks, trackerMainQueue);
-            if (gg.airplane.AirplaneConfig.multithreadedEntityTracker && this.world.getChunkProvider().entityTickingChunks.size() > 1000) {
+            if (gg.airplane.AirplaneConfig.multithreadedEntityTracker && (this.world.getChunkProvider().entityTickingChunks.size() * (this.world.getMinecraftServer().getPlayerCount() * 2 + 1)) > 1000) {
                 this.trackQueue.start();
                 return;
             }
@@ -2162,6 +2176,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         } finally {
             this.world.timings.tracker1.stopTiming();
+            ((ProtectedVisibleChunksMap) this.visibleChunks).readOnly = false; // Airplane - readonly protection
         }
     }
     // Paper end - optimised tracker
@@ -2410,8 +2425,9 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
         // Paper start
         // Replace trackedPlayers Set with a Map. The value is true until the player receives
         // their first update (which is forced to have absolute coordinates), false afterward.
-        public java.util.Map<EntityPlayer, Boolean> trackedPlayerMap = new java.util.HashMap<>();
+        public java.util.Map<EntityPlayer, Boolean> trackedPlayerMap = new Object2ObjectOpenHashMap<>(); // Airplane
         public Set<EntityPlayer> trackedPlayers = trackedPlayerMap.keySet();
+        private final java.util.concurrent.locks.ReadWriteLock trackedPlayersLock = new java.util.concurrent.locks.ReentrantReadWriteLock(true); // Airplane - sync
 
         public EntityTracker(Entity entity, int i, int j, boolean flag) {
             this.trackerEntry = new EntityTrackerEntry(PlayerChunkMap.this.world, entity, j, flag, this::broadcast, trackedPlayerMap); // CraftBukkit // Paper
@@ -2423,9 +2439,7 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
         // Paper start - use distance map to optimise tracker
         com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> lastTrackerCandidates;
 
-        synchronized final void tickEntry() { this.trackerEntry.tick(); } // Airplane - move entry tick into sync block
-
-        synchronized final void updatePlayers(com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newTrackerCandidates) { // Airplane
+        final void updatePlayers(com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newTrackerCandidates) {
             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> oldTrackerCandidates = this.lastTrackerCandidates;
             this.lastTrackerCandidates = newTrackerCandidates;
 
@@ -2450,7 +2464,16 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
             // stuff could have been removed, so we need to check the trackedPlayers set
             // for players that were removed
 
-            for (EntityPlayer player : this.trackedPlayers.toArray(new EntityPlayer[0])) { // avoid CME
+            // Airplane start - sync
+            final EntityPlayer[] trackedPlayers; // avoid CME
+            this.trackedPlayersLock.readLock().lock();
+            try {
+                trackedPlayers = this.trackedPlayers.toArray(new EntityPlayer[0]);
+            } finally {
+                this.trackedPlayersLock.readLock().unlock();
+            }
+            for (EntityPlayer player : trackedPlayers) {
+                // Airplane end
                 if (newTrackerCandidates == null || !newTrackerCandidates.contains(player)) {
                     this.updatePlayer(player);
                 }
@@ -2466,12 +2489,18 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
             return this.tracker.getId();
         }
 
-        public synchronized void broadcast(Packet<?> packet) { // Airplane - syncronized for tracked player
-            Iterator iterator = this.trackedPlayers.iterator();
-
-            while (iterator.hasNext()) {
-                EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+        public void broadcast(Packet<?> packet) {
+            // Airplane start - sync
+            final EntityPlayer[] trackedPlayers;
+            this.trackedPlayersLock.readLock().lock();
+            try {
+                trackedPlayers = this.trackedPlayers.toArray(new EntityPlayer[0]);
+            } finally {
+                this.trackedPlayersLock.readLock().unlock();
+            }
+            // Airplane end
 
+            for (EntityPlayer entityplayer : trackedPlayers) { // Airplane - avoid CME
                 entityplayer.playerConnection.sendPacket(packet);
             }
 
@@ -2486,11 +2515,17 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
         }
 
         public void a() {
-            Iterator iterator = this.trackedPlayers.iterator();
-
-            while (iterator.hasNext()) {
-                EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+            // Airplane start - sync
+            final EntityPlayer[] trackedPlayers;
+            this.trackedPlayersLock.readLock().lock();
+            try {
+                trackedPlayers = this.trackedPlayers.toArray(new EntityPlayer[0]);
+            } finally {
+                this.trackedPlayersLock.readLock().unlock();
+            }
 
+            for (EntityPlayer entityplayer : trackedPlayers) {
+                // Airplane end
                 this.trackerEntry.a(entityplayer);
             }
 
@@ -2498,7 +2533,16 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
 
         public void clear(EntityPlayer entityplayer) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot
-            if (this.trackedPlayers.remove(entityplayer)) {
+            // Airplane start - sync
+            final boolean exists;
+            this.trackedPlayersLock.writeLock().lock();
+            try {
+                exists = this.trackedPlayers.remove(entityplayer);
+            } finally {
+                this.trackedPlayersLock.writeLock().unlock();
+            }
+            if (exists) {
+                // Airplane end
                 this.trackerEntry.a(entityplayer);
             }
 
@@ -2521,7 +2565,7 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
 
                     if (!flag1) {
                         ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(this.tracker.chunkX, this.tracker.chunkZ);
-                        PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
+                        PlayerChunk playerchunk = PlayerChunkMap.this.trackerGetVisibleChunk(chunkcoordintpair.pair()); // Airplane
 
                         if (playerchunk != null && playerchunk.getSendingChunk() != null) { // Paper - no-tick view distance
                             flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.viewDistance;
@@ -2542,8 +2586,19 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
                     if (flag1 && this.trackedPlayerMap.putIfAbsent(entityplayer, true) == null) { // Paper
                         this.trackerEntry.b(entityplayer);
                     }
-                } else if (this.trackedPlayers.remove(entityplayer)) {
-                    this.trackerEntry.a(entityplayer);
+                    // Airplane start - sync
+                } else {
+                    final boolean exists;
+                    this.trackedPlayersLock.writeLock().lock();
+                    try {
+                        exists = this.trackedPlayers.remove(entityplayer);
+                    } finally {
+                        this.trackedPlayersLock.writeLock().unlock();
+                    }
+                    if (exists) {
+                        this.trackerEntry.a(entityplayer);
+                    }
+                    // Airplane end
                 }
 
             }
